[
  {
    "name": "Dart-Sass-install.md",
    "path": "src/content/posts/Dart-Sass-install.md",
    "sha": "3fd89c35891dc7ef77d9f1b86038a68810632403",
    "size": 2849,
    "content": "---\ntitle       : 'Dart Sass 安装过程的小坑'\ndate        : '2023-7-18'\ntags        : ['sass', '笔记']\npublish     : 'sass'\ndescription : '偶然发现官方已经不再支持 Ruby sass 了，改用了安装更方便、速度更快的 Dart Sass 和 LibSass。我啪的一下，很快啊……'\n---\n\n## 前言\n\n今天偶然发现官方已经不再支持 Ruby sass 了，改用了安装更方便、速度更快的 Dart Sass 和 LibSass。\n\n传送门：<https://sass-lang.com/ruby-sass/>\n\n我啪的一下，很快就卸载了 Ruby。\n\n接着安装 Dart Sass 也很顺利，直接解压到常用的安装路径，并且在高级设置里设置可执行文件目录的路径即可。\n\n传送门：<https://github.com/sass/dart-sass/releases>\n\n## 坑\n\n在 Git Bash 中使用 `sass --version` 居然显示找不到命令。而在 CMD 中却是正常地输出了 sass 版本。\n\n```sh\n$ sass --version\n# bash: sass: command not found\n```\n\n一番查找原因，发现 Dart Sass 安装目录下面只有 sass.bat。然而在 git bash 中需要写完整才能执行。\n\n也就是说：\n\n```sh\n$ sass.bat --version\n# 1.63.6\n```\n\n这样才能正常工作。\n\n## 解决方案\n\n方法一：\n\n为 sass.bat 起一个别名。\n\n```sh\nalias sass=\"sass.bat\"\n```\n\n方法二：\n\n把 sass.bat 文件转为 .sh 文件。\n\n步骤：\n\n1. 找到 sass.bat 文件所在位置\n2. 然后新建一个文件，文件名改成 sass（不需要后缀）\n3. 然后把下面已经转换为 bash 的代码复制进 sass 文件：\n\n    ```sh\n    #!/bin/bash\n    # This script drives the standalone dart-sass package, which bundles together a\n    # Dart executable and a snapshot of dart-sass.\n\n    SCRIPTPATH=\"$( cd \"$(dirname \"$0\")\" >/dev/null 2>&1 ; pwd -P )\"\n    arguments=\"$@\"\n    \"$SCRIPTPATH/src/dart.exe\" \"$SCRIPTPATH/src/sass.snapshot\" \"$arguments\"\n    ```\n\n4. 保存\n5. 在 sass.bat 文件所在位置，打开命令行，执行 `chmod +x sass` 命令。\n6. 然后执行 `sass --version` 命令测试是否正确输出版本信息。\n\n下面是 GPT 对 `chmod` 命令的解释：\n\n`chmod` 是一个命令，用于更改文件的权限。在这种情况下，`+x` 参数表示要为文件添加可执行权限。具体解释如下：\n\n- `+x`：表示添加可执行权限。\n- `-x`：表示删除可执行权限。\n- `u`：表示文件的所有者。\n- `g`：表示文件所属组。\n- `o`：表示其他用户。\n- `a`：表示所有用户（包括所有者、所属组和其他用户）。\n\n因此，`chmod +x sass` 命令将为文件 sass 添加可执行权限，使得该文件可以作为可执行程序在终端中运行。\n\n需要注意的是，只有具有可执行权限的脚本或可执行文件才能在终端中直接执行。通过运行 `chmod +x sass` 命令，您为文件添加了可执行权限，使得在 Git Bash 中可以直接运行 sass 命令。\n",
    "meta": {
      "title": "Dart Sass 安装过程的小坑",
      "date": "2023-7-18",
      "tags": [
        "sass",
        "笔记"
      ],
      "publish": "sass",
      "description": "偶然发现官方已经不再支持 Ruby sass 了，改用了安装更方便、速度更快的 Dart Sass 和 LibSass。我啪的一下，很快啊……"
    }
  },
  {
    "name": "CSS-BFC-learn.md",
    "path": "src/content/posts/CSS-BFC-learn.md",
    "sha": "c12e381c97e4cce9fac6d4b68b43438a9ea720a2",
    "size": 2638,
    "content": "---\ntitle       : 'BFC 介绍及其应用'\ndate        : '2023-7-16'\ntags        : ['CSS', '笔记']\npublish     : 'CSS'\ndescription : 'BFC（Block Formatting Contexts 块级格式化上下文）是 CSS 中的一个重要概念。它是页面上一个独立的渲染区域，如果一个元素具有 BFC 特性，则内部子元素在任何情况下都不会影响到外部元素，也不会被外部元素影响。'\n---\n\n## 概念\n\nBFC（Block Formatting Contexts 块级格式化上下文）是 CSS 中的一个重要概念。它是页面上一个独立的渲染区域，如果一个元素具有 BFC 特性，则内部子元素在任何情况下都不会影响到外部元素，也不会被外部元素影响。\n\n例如：\n\n1. **处理浮动问题**：当父元素包含浮动元素时，父元素的高度坍塌，这导致父元素无法包裹子元素。但是，当父元素具有 BFC 特性时，它会包含浮动元素并计算其高度，解决了这个问题。\n\n2. **防止边距重叠**：在普通流中，相邻两个元素的 margin 可能会重叠。但是，当两个元素属于不同的 BFC 时，它们的边距不会重叠。\n\n## 元素在什么时候具有 BFC 特性？\n\n- `html` 根元素。天生具有。\n- `float` 的值不为 none。\n- `position` 的值不为 relative、static。\n- `overflow` 的值为 auto、scroll、hidden。\n- `display` 的值为 inline-block、table-cell、table-caption、flex、grid。\n\n## BFC 与布局\n\n```html\n<div class=\"demo\">\n  <img src=\"./example.jpg\" />\n  <div class=\"content\">\n    BFC（Block Formatting Contexts 块级格式化上下文）是 CSS\n    中的一个重要概念。它是页面上一个独立的渲染区域，如果一个元素具有 BFC\n    特性的话，内部子元素在任何情况下都不会影响到外部的元素。\n  </div>\n</div>\n\n<style>\n  img {\n    float: left;\n\n    width: 100px;\n    margin-right: 12px;\n  }\n\n  .content {\n    overflow: hidden;\n  }\n</style>\n```\n\n上面代码，img 设置了 `float` 属性具有了 BFC 和原有的浮动特性，所以 img 会尽可能地靠左浮动。\n\n此时 div.content 的文字会受到 img 的 `float` 属性环绕 img，但是 div.content 设置了 `overflow` 属性也具有 BFC 特性：BFC 元素的子元素不会受到外部元素的影响。所以 div.content 就不会环绕 img。\n\n可以通过改变 img 宽度大小会发现 div.content 内容是自适应的。如果元素之间需要间隔，这里推荐在 img 中设置 `margin` 属性或其他，但是不推荐在 div.content 上设置 `margin-left`，因为该值必须是浮动元素的宽度加上间隙的大小，可复用性差。\n",
    "meta": {
      "title": "BFC 介绍及其应用",
      "date": "2023-7-16",
      "tags": [
        "CSS",
        "笔记"
      ],
      "publish": "CSS",
      "description": "BFC（Block Formatting Contexts 块级格式化上下文）是 CSS 中的一个重要概念。它是页面上一个独立的渲染区域，如果一个元素具有 BFC 特性，则内部子元素在任何情况下都不会影响到外部元素，也不会被外部元素影响。"
    }
  },
  {
    "name": "html-plus.md",
    "path": "src/content/posts/html-plus.md",
    "sha": "9e89ac0d7724d03a42c17d6817403e961a2cc4b2",
    "size": 6109,
    "content": "---\ntitle       : '折腾|一次原生项目的最佳实践的探索'\ndate        : '2023-5-23'\ntags        : ['JavaScript', '折腾']\npublish     : 'JavaScript'\ncover       : 'htmlPlus.webp'\ndescription : '关于我重构项目时的一番折腾……'\n---\n\n## 前言\n\n因为一些原因，前些天，我在重构以前写的一个期末大作业项目😣。\n\n刚开始重构项目，我就开始怀念vue了😂\n\n我选择元素时是这样做的：\n\n```js\nconst $ = (e) => document.querySelector(e)\nconst $$ = (e) => document.querySelectorAll(e)\n\n$('.box').xxx\n```\n\n全局暴露 `$`、 `$$` 方法来方便获取元素。\n\nemmm，这样其实也还行，对于原生项目来说……\n\n不过，我的折腾病，可不允许我就这样。\n\n## 设想\n\n原生项目似乎没有组件的概念，我最多是见过使用 `<iframe>` 来达成组件效果的（我也不确定这样做是不是为了组件化）。\n\nUI 组件化似乎没法达成了，但我想了想业务逻辑还是有可能的。\n\n可以写一个类，用面向对象的思维，把某一个 html 范围的业务逻辑写在一个类里面。\n\n我就暂且称之为“模块”吧。\n\n```js\nclass ExampleBox {\n  constructor(selector) {\n    this.$el = document.querySelector(selector)\n  }\n}\n\nnew ExampleBox('.example-box')\n```\n\n这样就可以在 `ExampleBox` 里面使用 `this.$el.querySelector('xxx')` 获取对应 html 内的元素了，并且可以把该元素直接挂在 `ExampleBox` 实例里面。\n\n## ref 指令\n\n但这样还是不方便……还是需要自己写 `querySelector`。\n\n是否可以直接在 html 上标记元素，然后就可以在 `ExampleBox` 实例里面拿到元素？就像 vue 的 ref 属性一样。\n\n开搞~\n\n设想：在 html 标签上通过 `data-ref` 标记该元素，然后 `new ExampleBox()` 时候调用 `this.$el.querySelector()` 获取该元素，并将 `data-ref` 的值作为 key 放在实例上。\n\n实现：\n\n```html\n<div class=\"example-box\">\n  <p data-ref=\"question\">问世间帅为何物？</p>\n</div>\n```\n\n```js\nclass Base {\n  constructor(selector) {\n    this.$el = document.querySelector(selector)\n    this.initRef()\n  }\n  \n  initRef() {\n    const refNodes = this.getNodeAll('[data-ref]')\n\n    for (let node of refNodes) {\n      const key = node.dataset.ref\n      this[key] = node\n    }\n  }\n\n  getNode(selector) {\n    return this.$el.querySelector(selector)\n  }\n\n  getNodeAll(selector) {\n    return this.$el.querySelectorAll(selector)\n  }\n}\n```\n\n```js\nclass ExampleBox extends Base {\n  constructor(selector) {\n    super(selector)\n  }\n}\n\nconsole.log(new ExampleBox('.example-box'))\n```\n\n打印 `ExampleBox` 实例就可以看到：\n\n![Alt text](</images/html-plus/1.png>)\n\n看来是成功了😂。\n\n上面写了一个 `Base` 的基础类可以让每一个“模块”继承以获得 `ref` 指令的功能。\n\n## event 指令\n\n不用10分钟的时间就完成上面的 `ref` 指令功能，我已经开始飘了，我脑子🧠又产生了大量想法。\n\n于是我又用5分钟实现了 `event` 指令（事件绑定）功能。\n\n```html\n<div class=\"example-box\">\n  <p data-ref=\"question\">问世间帅为何物？</p>\n\n  <button data-event=\"click:showAnswer\">点我查看答案</button>\n</div>\n```\n\n```js\n// base\n\ninitEvent() {\n  const eventNodes = this.getNodeAll('[data-event]')\n\n  for (let node of eventNodes) {\n    const [eventName, methodName] = node.dataset.event.split(':')\n\n    node.addEventListener(eventName, this[methodName].bind(this))\n  }\n}\n```\n\n```js\nclass ExampleBox extends Base {\n  constructor(selector) {\n    super(selector)\n  }\n\n  showAnswer() {\n    this.question.innerHTML = '唯默小言独占也。'\n  }\n}\n\nconsole.log(new ExampleBox('.example-box'))\n```\n\n`data-event` 指令使用 `:` 来区分不同的参数。\n\n## clone & bind 指令\n\n上面的 `ref` 和 `event` 指令都很顺利，令我我折腾病大发作。\n\n我继续观察我要重构的原生项目，看看还有哪些痛点，需要解决。\n\n果不奇然，项目都是发送请求，拿到响应数据之后就开始根据数据克隆对应数量的 html 节点，然后`$('...').innerHTML= [数据]` 😓\n\n如果有 `clone` 和 `bind` 指令就可以解决这个问题了🧐。\n\n设想：\n\n```html\n<ul class=\"example-box\">\n  <template data-clone=\"listItem1:true:arr\">\n    <li data-target=\"listItem\">\n      <p data-bind=\"innerHTML:name\"></p>\n\n      <template data-clone=\"spanItem:false:images\">\n        <p data-target=\"spanItem\" data-bind=\"innerHTML:$item\"></p>\n      </template>\n    </li>\n  </template>\n</ul>\n```\n\n```js\nconst dataObj = {\n  arr: [\n    {\n      name: 'xiaoyan-1',\n      images: [1, 2, 3],\n    },\n    {\n      name: 'xiaoyan-2',\n      images: [4, 5, 6],\n    },\n    {\n      name: 'xiaoyan-3',\n      images: [7, 8, 9],\n    },\n  ],\n}\n```\n\n`data-clone` 应该只用在 `<template>` 上。\n\n从上面 html 可以看到该指令有三个参数，分别是：\n\n- listItem/spanItem 用来识别克隆的目标，与对应 `<template>` 的第一个元素的 `data-target` 对应\n- true/false 表示是否进行深度克隆\n- arr/images 都是进行克隆的数据，且是一个数组。\n\n`data-bind` 的第一个参数是元素的属性，例如：innerHTML、innerText、className、id……，第二个参数是需要绑定的数据。\n\n例如：`arr` 有三个元素，就意味会会把 `<li>` 克隆3次，并把克隆的结果添加到父元素内。注意：`arr` 第一个元素的数据就对应着第一个克隆的 `<li>` 节点，所以 `bind` 指令就能正确地绑定数据。\n\n细心的同学可能发现了 `bind` 指令有一个特殊的参数（`$item`），它用于绑定对应的数组元素。这不好解释，我直接上一个效果图，估计就能看明白了。\n\n![Alt text](</images/html-plus/2.png>)\n\n由于，实现这两个指令的代码有点长，就不放在这文章里面了。\n\n感兴趣的可以查看：[项目地址](<https://github.com/2113ic/dot/tree/master/public/package/htmlPlus>)\n\n## 结论\n\n其实这个东西（Base类）没啥大用，不过能满足我的折腾病了。\n\n真要用在实际项目，还是用框架方便🤣\n",
    "meta": {
      "title": "折腾|一次原生项目的最佳实践的探索",
      "date": "2023-5-23",
      "tags": [
        "JavaScript",
        "折腾"
      ],
      "publish": "JavaScript",
      "cover": "htmlPlus.webp",
      "description": "关于我重构项目时的一番折腾……"
    }
  },
  {
    "name": "Git-learn-note.md",
    "path": "src/content/posts/Git-learn-note.md",
    "sha": "80029ac2633678f0d1740c0bc687b422280581ce",
    "size": 13048,
    "content": "---\ntitle       : '我的Git学习笔记'\ndate        : '2023-4-28'\ntags        : ['git']\npublish     : 'git'\ndescription : '狂写代码一时爽，git commit 火葬场。经历两次丢失代码的痛苦后，我决定要好好学习一下git……'\n---\n\ngit 是一种源码管理系统（source code management，缩写为 SCM）。它对当前文件提供版本管理功能，核心思想是对当前文件建立一个对象数据库，将历史版本信息存放在这个数据库中。\n\n## 安装\n\n1. 安装 git\n\n   [官网下载地址](https://git-scm.com/)\n\n   在终端中执行 `git --version` 命令，如果显示 git 的版本说明安装成功。\n\n2. 提交用户名和电子邮件\n\n    这些信息将作为提交者信息显示在更新历史中。\n\n    ```sh\n    git config --global user.name 'you'\n    git config --global user.email 'you@gmail.com'\n    ```\n\n    | 选项       | 说明                     |\n    | ---------- | ------------------------ |\n    | `--global` | 表示全局设置用户名或邮箱 |\n\n    - 注意：`user.email` 应该填写你 GitHub 的 email，否则 GitHub 无法识别是哪个用户，该 commit 也不会记录在你空间的活动表中。\n    - 注意：如果不添加 `--global` 那么将设置为当前项目的配置，你可以在 .git 文件夹的 config 文件中看到你的配置。\n\n    git 的全局设定被存放在用户本地目录的 .gitconfig 文件里，也可以直接编辑该配置文件。\n\n    ```yaml\n    [user]\n      name = you\n      email = you@gmail.com\n    ```\n\n3. 查看当前项目的配置信息\n\n   ```sh\n   # 查看所有配置信息\n   git config --list\n   \n   # 查看用户名\n   git config user.name\n   \n   #查看电子邮件\n   git config user.email\n   ```\n\n   添加 `–-global` 将查看全局的配置信息。\n\n## 基本概念\n\n**工作区**：\n\n工作区也称“工作树”，是实际被操作的目录，可以理解为实际项目的目录。\n\n**暂存区**：\n\n暂存区也称“索引”，是为了向数据库提交作准备的区域。Git 在执行提交的时候，不是直接将工作区的更改直接保存到数据库，而是将暂存区的更改保存到数据库。\n\n将工作区的更改添加到暂存区之后，就意味着该文件已被“跟踪”。\n\n**数据库**：\n\ngit 的数据库为两种：\n\n- 远程数据库：配有专用的服务器，为了多人共享而建立的数据库。\n- 本地数据库：为了方便用户个人使用，在自己的机器上配置的数据库。\n\n通常的 `git commit` 操作是将更改提交到本地数据库，而 `git push` 则是将更改提交到远程数据库。\n\n**分支**：\n\n分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。\n\n一个项目一般会建立多个分支。例如：当功能分支或修复 bug 的分支写好后可以合并分支到主分支中。\n\n注意：在本地创建项目 git 会创建一个名为 master 的分支（如果是在GitHub创建的仓库会是 main 的分支）。因此之后的提交，在切换分支之前都会添加到 master 分支里。\n\n## 操作流程\n\n1. 初始化一个 git 仓库\n\n   ```sh\n   git init\n   ```\n\n2. 查看当前仓库状态\n\n   ```sh\n   git status\n   ```\n\n3. 将文件从工作区添加到暂存区\n\n   ```sh\n   git add [file1] [file2] ...\n   ```\n\n4. 将暂存区的文件提交到本地代码仓库\n\n   ```sh\n   git commit -m [message]\n   ```\n\n5. 查看提交 commit 的信息\n\n   ```sh\n   git log\n   ```\n\n6. 添加远程指针\n\n   ```sh\n   git add remote origin <url>\n   ```\n\n7. 将本机的 master 分支推送到远程 origin 主机\n\n   ```sh\n   git push -u origin master\n   ```\n\n8. 将远程主机 origin 的代码取回本地，与本地的 master 分支合并\n\n   ```sh\n   git pull origin master\n   ```\n\n9. 比较当前分支和上一次 commmit 的差异\n\n   ```sh\n   git diff HEAD\n   ```\n\n## 基本操作\n\n### 增加\n\n```sh\n# 添加指定文件到暂存区\ngit add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\ngit add [dir]\n\n# 添加当前目录的所有文件到暂存区\ngit add .\n```\n\n| 选项 | 说明                         |\n| ---- | ---------------------------- |\n| `-u`   | 只添加已提交过的文件到暂存区 |\n| `-p`   | 只添加文件修改的其中一部分   |\n| `-i`   | 用对话的形式显示添加在暂存区 |\n\n### 删除\n\n```sh\n# 删除指定文件，并把这次删除放入暂存区\ngit rm [file1] [file2]\n\n# 停止跟踪指定文件，但该文件会保留在工作区\ngit rm --cached [file]\n\n# 改名，并放入暂存区\ngit mv [file-original] [file-renamed]\n```\n\n| 选项       | 说明     |\n| ---------- | -------- |\n| `--cached` | 停止跟踪 |\n\n### 提交\n\n```sh\n# 提交暂存区到本地仓库\ngit commit -m [message]\n\n# 提交暂存区指定的文件到本地仓库\ngit commit [file1] [file2] ... -m [message]\n\n# 如果代码没有任何新变化，则改写上一次commit的提交信息\ngit commit --amend -m [message]\n\n# 重做上一次commit，并指定文件的新变化\ngit commit --amend <file1> <file2> ... -m [message]\n```\n\n| 选项      | 说明                                   |\n| --------- | -------------------------------------- |\n| `-a`        | 直接提交所有工作区、暂存区未提交的更改 |\n| `-m`        | 指定提交 `[message]` 里的信息          |\n| `-v`        | 提交时显示所有 diff 信息               |\n| `--amend` | 改写提交                               |\n\n### 分支\n\n1. 查看分支\n\n   ```sh\n   # 列出所有本地分支\n   git branch\n   ```\n\n   | 选项 | 说明             |\n   | ---- | ---------------- |\n   | `-r`   | 列出所有远程分支 |\n   | `-a`   | 列出所有分支     |\n\n2. 创建分支\n\n   ```sh\n   # 新建分支，但依然停留在当前分支\n   git branch [new-branch-name]\n   \n   # 将当前分支重命名\n   git branch -m [new-branch-name]\n   \n   # 新建分支，指向指定 commit\n   # [commit] 是要将新分支指向的提交记录的哈希值、分支名或者是其他引用名称。\n   # 如果不指定，则默认是当前所在的提交记录。\n   git branch [new-branch-name] [commit]\n   \n   # 新建分支，与指定的远程分支建立跟踪关系\n   git branch --track [new-branch-name] [remote-branch]\n   \n   # 在现有分支与指定的远程分支之间，建立跟踪关系\n   git branch -u [branch-name] [remote-branch]\n   ```\n\n   | 选项    | 说明                                               |\n   | ------- | -------------------------------------------------- |\n   | `--track` | 创建一个新的本地分支，并将其与远程分支建立跟踪关系 |\n   | `-u`      | 设置跟踪关系                                       |\n   | `-m`      | 重命名分支                                         |\n\n3. 切换分支\n\n   ```sh\n   # 切换到指定分支，并更新工作区\n   git checkout [branch-name]\n   \n   # 新建一个分支，指向某个 tag\n   git checkout -b [branch-name] [tag]\n   ```\n\n   | 选项 | 说明                         |\n   | ---- | ---------------------------- |\n   | `-b`   | 新建一个分支，并切换到该分支 |\n\n4. 合并分支\n\n   ```sh\n   # 合并指定分支到当前分支\n   git merge [branch-name]\n   \n   # 选择一个 commit，合并进当前分支\n   git cherry-pick [commit]\n   ```\n\n5. 删除分支\n\n   ```sh\n   git branch -d [branch-name]\n   \n   # 删除远程分支\n   git push origin -d [branch-name]\n   # 从本地仓库的跟踪分支列表中删除指定的远程分支\n   # 不会影响远程分支\n   git branch -dr <remote/branch-name>\n   ```\n\n   | 选项 | 说明                                 |\n   | ---- | ------------------------------------ |\n   | `-d`   | 用于删除指定的本地分支或远程跟踪分支 |\n   | `-r`   | 用于指定要删除的远程跟踪分支         |\n   | `-D`   | 强制删除分支，不管有没有合并更改     |\n\n### 标签\n\n1. 查看\n\n   ```sh\n   # 列出所有 tag\n   git tag\n   \n   # 查看 tag 信息\n   git show [tag]\n   ```\n\n2. 新建 tag\n\n   ```sh\n   # 新建一个 tag 在当前 commit\n   git tag [tag]\n   \n   # 新建一个 tag 在指定 commit\n   git tag [tag] [commit]\n   ```\n\n3. 删除 tag\n\n   ```sh\n   git tag -d [tag]\n   ```\n\n4. 提交 tag\n\n   ```sh\n   # 提交指定 tag 到远程仓库\n   git push [remote] [tag]\n   ```\n\n   | 选项   | 说明         |\n   | ------ | ------------ |\n   | `--tags` | 提交所有 tag |\n\n### 查看信息\n\n1. 基础操作\n\n   ```sh\n   # 显示所有文件的变更状态\n   git status\n    \n   # 显示当前分支的最近几次提交\n   git reflog\n    \n   # 显示当前分支的版本历史\n   git log\n    \n   # 显示 commit 历史，以及每次 commit 发生变更的文件\n   git log --stat\n    \n   # 显示某个文件的版本历史，包括文件改名\n   git log --follow [file]\n    \n   # 显示指定文件相关的每一次 diff\n   git log -p [file]\n    \n   # 显示指定文件是什么人在什么时间修改过\n   git blame [file]\n   ```\n\n   | 选项  | 说明                           |\n   | ----- | ------------------------------ |\n   | `--stat` | 列出每个提交的文件更改统计信息 |\n   | `-p` | 显示每个提交中某文件的详细更改内容 |\n   | `--follow` | 跟踪某文件的重命名和移动操作 |\n\n2. diff 操作\n\n   ```sh\n   # 比较暂存区和工作区的差异\n   git diff\n   \n   # 比较暂存区和上一个 commit 的差异\n   git diff --cached\n   \n   # 比较暂存区和上一个 commit 的特定文件的差异\n   git diff --cached [file]\n   \n   # 比较工作区与当前分支最新 commit 之间的差异\n   git diff HEAD\n   \n   # 比较两个分支/提交之间的差异\n   git diff [branch1/commit1]...[branch2/commit2] # ①\n   ```\n\n   - 注意：①这个命令中的三个点号（`...`）是必须的，它们表示比较的方向，即从左往右比较 `branch1` 和 `branch2`，从右往左比较 `branch2` 和 `branch1`，然后将两次比较的结果合并起来输出。\n   - 注意：①这个命令只会输出差异信息，并不会将这些差异合并到任何一个分支中。如果需要将差异合并到某个分支中，需要使用 `git merge` 命令或其他合并命令。\n\n3. show 操作\n\n   ```sh\n   # 显示某次提交的元数据和内容变化\n   git show [commit]\n   \n   # 显示某次提交发生变化的文件\n   git show --name-only [commit]\n   \n   # 显示某次提交时，某个文件的内容\n   git show [commit]:[filename]\n   ```\n\n### 远程\n\n- 查看\n\n  ```sh\n  # 显示所有远程仓库\n  git remote -v\n\n  # 显示某个远程仓库的信息\n  git remote show [remote]\n\n  # 下载远程仓库的所有变动\n  git fetch [remote]\n  ```\n\n- 新建远程仓库\n\n  ```sh\n  # 增加一个新的远程仓库，并命名\n  git remote add [shortname] [url]\n  ```\n\n- 克隆远程仓库\n\n  ```sh\n  # 克隆远程仓库\n  # [dir] 为指定新目录的名称，默认为远程仓库的名称\n  git clone <repository-url> [dir]\n  ```\n\n- push 操作\n\n  ```sh\n  # 上传本地指定分支到远程仓库，不指定则默认为当前分支\n  git push [remote] [branch]\n  ```\n\n  | 选项    | 说明                                   |\n  | ------- | -------------------------------------- |\n  | `--force` | 强行推送当前分支到远程仓库，即使有冲突 |\n  | `--all`   | 推送所有分支到远程仓库                 |\n\n- pull 操作\n\n  ```sh\n  # 取回远程仓库的变化，并与本地分支合并\n  git pull [remote] [branch]\n  ```\n\n### 撤销\n\n1. checkout操作\n\n   ```sh\n   # 恢复暂存区的指定文件到工作区\n   git checkout [file]\n   \n   # 恢复某个 commit 的指定文件到工作区\n   git checkout [commit] [file]\n   \n   # 恢复上一个 commit 的所有文件到工作区\n   git checkout .\n   ```\n\n2. reset 操作\n\n   ```sh\n   # 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n   git reset [file]\n   \n   # 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n   git reset [commit]\n   \n   # 重置暂存区与工作区，如果没有指定 commit，则默认与上一次 commit 保持一致\n   git reset --hard [commit]\n   ```\n\n   | 选项 | 说明 |\n   | ---- | ---- |\n   | `--hard`   | 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 |\n   | `--keep` | 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 |\n\n   注意：使用 `--hard` 之前请备份未提交的更改，否则会导致未提交的更改**永久丢失**！\n\n3. revert 操作\n\n   ```sh\n   # 新建一个 commit，用来撤销指定 commit\n   # 后者的所有变化都将被前者抵消，并且应用到当前分支\n   git revert [commit]\n   ```\n\n### 其他\n\n```sh\n# 生成一个可供发布的压缩包\ngit archive\n```\n\n## 参考\n\n- wangdoc/git-tutorial：<https://github.com/wangdoc/git-tutorial>\n\n- 猴子都能懂的Git教程：<https://backlog.com/git-tutorial/cn/>\n",
    "meta": {
      "title": "我的Git学习笔记",
      "date": "2023-4-28",
      "tags": [
        "git"
      ],
      "publish": "git",
      "description": "狂写代码一时爽，git commit 火葬场。经历两次丢失代码的痛苦后，我决定要好好学习一下git……"
    }
  },
  {
    "name": "regexp-learn.md",
    "path": "src/content/posts/regexp-learn.md",
    "sha": "7a1fef9ede5c2e4e2744b4207f78185f535ecbe9",
    "size": 20885,
    "content": "---\ntitle       : 'JavaScript 之正则表达式'\ndate        : '2022-7-2'\ntags        : ['Regexp']\npublish     : 'Regexp'\ndescription : '正则表达式学习笔记'\n---\n\n## 正则表达式的创建\n\n**方法一**：`new RegExp(\"pattern\"[, \"flags\"])`\n\n其中，pattern 称为模式。flags 称为标志。这种方式可以实现动态改变正则。（运行时编译）\n\n```javascript\nconst regText = 'yan';\nconst str = 'xiaoyan';\nconst regexp = new RegExp(\"[\"+ regText +\"]\");\n\nconsole.log(regexp.test(str));\n// true\n```\n\n注意，使用构造器创建正则时，需要进行转义。原因是 `“”` 会消耗一个`\\`。\n\n```javascript\nconst reg1 = new RegExp(\"\\\\w+\");\nconst reg2 = /\\w+/;\n\n// reg1 和 reg2 作用相同。\n```\n\n如果要把特殊字符作为常规字符来使用，也只需要在它前面加个反斜杠。\n\n**方法二**：`/pattern/[flags]`\n\n这种方式只能是固定的匹配格式。（编译状态）\n\n```javascript\nconst regexp = /\\w+/i;\n```\n\n## 正则表达式的实例\n\n```javascript\n// 控制台输入\nconsole.dir(/\\w+/);\n\n// 输出\n{\n  // 表示从哪里开始下一个匹配\n  lastIndex: 0,\n\n  // .号是否要多行匹配\n  dotAll: false,\n\n  // 修饰符\n  flags: \"\",\n\n  // 全局匹配（与修饰符g 作用相同）\n  global: false,\n\n  // 是否启用\\d 标志\n  hasIndices: false,\n\n  // 是否忽略大小写（与修饰符i 作用相同）\n  ignoreCase: false,\n\n  // 是否要多行搜索\n  multiline:false,\n\n  // 正则表达式的文本\n  source: \"\\\\w+\",\n \n  // 是否启用粘性\n  sticky: false,\n\n  // 是否启用Unicode 功能\n  unicode: false\n}\n```\n\n## API\n\n### RegExp\n\n#### regexp.exec(str)\n\n在一个指定字符串中执行一个搜索匹配。\n\n返回值：一个数组或null。\n\n当正则表达式没有标识符`g`时：\n\n```javascript\nconst str = \"I love JavaScript\";\nconst result = /Java(Script)/.exec(str);\n\nconsole.dir(result);\n\n// 以一个数组形式返回\n[\n    // 完全匹配项\n    0: \"JavaScript\",\n\n    // 捕获组的匹配项\n    1: \"Script\",\n\n    // 分组\n    groups: undefined,\n\n    // 匹配的位置\n    index: 7,\n\n    // 输入的字符串\n    input: \"I love JavaScript\",\n\n    length: 2\n]\n```\n\n当正则表达式有标识符`g`时：\n\n```javascript\nconst str = \"I love JavaScript\";\nconst exp = /Java(Script)/g;\nconst result = exp.exec(str);\n\nconsole.dir(exp);\n\n// exp 会记录下紧随匹配项其后的位置在属性 lastIndex 中，\n// 下次同样使用改表达式时会从位置 lastIndex 开始搜索。\n{\n  lastIndex: 17,\n  flags: \"g\",\n  ……\n}\n```\n\n#### regexp.test(str)\n\n返回 true/false\n\n检验给定的字符串是否匹配正则表达式。\n\n如果正则表达式带有标志`g`，匹配将从`lastIndex` 开始查找，并更新此属性。与`exec`表现相同\n\n```javascript\nlet str = \"I love JavaScript\";\n\n// 这两个测试相同\nalert( /love/i.test(str) );          // true\nalert( str.search(/love/i) != -1 );  // true\n```\n\n### string\n\n#### str.match(regexp)\n\n返回一个数组或null。\n\n1. 当正则表达式没有`g`标志时，与`exec`表现相同。\n\n2. 当正则表达式带有`g`标志时，会将所有匹配项以数组形式返回，而不包含分组和其他详细信息。\n\n```javascript\nconst str = \"I love JavaScript and Java\";\n\nconst result = str.match(/Java(Script)?/ig);\n\nconsole.dir(result);\n\n[\n  0: \"JavaScript\",\n  1: \"Java\",\n\n  length: 2\n]\n```\n\n#### str.matchAll(regexp)\n\n返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。没有结果时，返回一个空的迭代器。\n\n迭代器不可重用，结果耗尽需要重新调用方法。\n\n`RegExp`必须是设置了全局模式`g`的形式，否则会抛出异常`TypeError`。\n\n注意，这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.\n\n```javascript\nlet str = '<h1>Hello, world!</h1>';\nlet regexp = /<(.*?)>/g;\n\nlet matchAll = str.matchAll(regexp);\n\nconsole.log(matchAll); // [object RegExp String Iterator]，不是数组，而是一个可迭代对象\n\nmatchAll = Array.from(matchAll); // 现在返回的是数组\n\nlet firstMatch = matchAll[0];\nconsole.log( firstMatch[0] );  // <h1>\nconsole.log( firstMatch[1] );  // h1\nconsole.log( firstMatch.index );  // 0\nconsole.log( firstMatch.input );  // <h1>Hello, world!</h1>\n```\n\n#### str.search(regexp)\n\n返回第一个匹配项的位置，如果未找到，则返回 `-1`\n\n仅能查找第一个普配项，需要查找更多，请用其他方法。\n\n#### str.split(regexp|substr, limit)\n\n能使用正则表达式或子字符串，作为分隔符来分割字符串。\n\n#### str.replace(regexp|substr, str|func)\n\n方法返回一个由替换值（`replacement`）替换部分或所有的模式（`pattern`）匹配项后的新字符串。\n\n模式可以是一个字符串或者一个正则表达式，\n\n替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。\n\n**如果`pattern`是字符串，则仅替换第一个匹配项**\n\n```javascript\nconst str = \"mo-xiao-yan\";\nconst result1 = str.replace(\"-\", \"\");\nconst result2 = str.replace(/-/g, \"\");\n\nconsole.log(result1); // moxiao-yan\nconsole.log(result2); // moxiaoyan\n```\n\n1. 如果`replace` 的第二个参数是要代替的字符串，可以在其中使用一些特殊的字符。\n\n    | 符号      | 替换字符中的操作                               |\n    | --------- | ---------------------------------------------- |\n    | `$&`      | 插入整个匹配项                                 |\n    | `$`        | 插入字符串中匹配项之前的字符串部分             |\n    | `$'`      | 插入字符串中匹配项之后的字符串部分             |\n    | `$n`      | 如果`n`是1到2位的数字，则插入第`n`个分组的内容 |\n    | `$<name>` | 插入带有给定的`name`的分组的内容               |\n    | `$$`      | 插入字符`$`                                    |\n\n     示例：\n\n    ```javascript\n     // 交换位置\n     const str = \"mo xiaoyan\";\n     const result = str.replace(/(mo) (xiaoyan)/, \"$2 $1\");\n     \n     console.log(result);\n    ```\n\n2. 如果`replace`的第二个参数是函数，每次匹配都会调用这个函数，并且返回的值将作为替换字符串插入。\n\n    `func(match, p1, p2, ..., pn, offset, input, groups)`\n\n    `match` - 匹配项。\n\n    `p1, p2,  … , pn` - 分组的内容（如果有分组的话）。\n\n    `offset` - 匹配项的位置。\n\n    `input` - 源字符串。\n\n    `groups` - 所指定分组的对象。\n\n    如果正则表达式中没有分组，则只有3个参数：`func(str, offset, input)`。\n\n## 锚点\n\n锚点 `^` 和 `$` 属于测试。它们的宽度为零。\n\n`^` 会匹配整个文本的开头。\n\n`$` 会匹配整个文本的结尾。\n\n```javascript\nconst str = \"Mary had a little lamb\";\n\nconsole.log( /^Mary/.test(str) ); // true\nconsole.log( /lamb$/.test(str) ); // true\n```\n\n这两个锚点 `^...$` 放在一起常常被用于测试一个字符串是否完全匹配一个模式。\n\n比如，测试用户的输入是否符合正确的格式。\n\n```javascript\nlet goodInput = \"12:34\";\nlet badInput = \"12:345\";\n\nlet regexp = /^\\d\\d:\\d\\d$/;\nconsole.log( regexp.test(goodInput) ); // true\nconsole.log( regexp.test(badInput) );  // false\n```\n\n## 词边界\n\n词边界 `\\b` 是一种检查，就像 `^` 和 `$` 一样。\n\n当正则表达式引擎执行模式遇到 `\\b` 时，它会检查字符串中的位置是否是词边界。\n\n有三种不同的位置可作为词边界：\n\n- 在字符串开头，如果第一个字符是单词字符 `\\w`。\n- 在字符串中的两个字符之间，其中一个是单词字符 `\\w`，另一个不是。\n- 在字符串末尾，如果最后一个字符是单词字符 `\\w`。\n\n```javascript\nconsole.log( \"Hello, Java!\".match(/\\bJava\\b/) );       // Java\nconsole.log( \"Hello, JavaScript!\".match(/\\bJava\\b/) ); // null\n```\n\n## 修饰符\n\n在JavaScript中有6个修饰符。\n\n`i` 使用此修饰符后，在搜索时不区分大小写。\n\n`g` 搜索时会查找所有匹配项，而不是只搜索第一个。\n\n`m` 多行模式。仅仅会影响 `^` 和 `$` 锚点符的行为。\n\n在多行模式下，它们不仅仅匹配文本的开始与结束，还匹配每一行的开始与结束。\n\n```javascript\nconst str = \n`1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\nconsole.log( str.match(/^\\d+/gm) ); // [1,2,33]\n```\n\n`s` 启用 dotAll 模式，允许`.` 匹配换行符`\\n` 。\n\n```javascript\nconsole.log( \"A\\nB\".match(/A.B/) );  // null (no match)\nconsole.log( \"A\\nB\".match(/A.B/s) ); // A\\nB (match!)\n```\n\n`u` 开启完整的 unicode 支持。该修饰符能够修正对于代理对的处理。\n\n一些数学符号、表情等字符，在JavaScript中的长度读取为2，但他们的实际长度为4。\n\n这是因为JavaScript问世时Unicode还没有长度为4的字符。\n\n```javascript\nconsole.log('😄'.length); // 2\nconsole.log('𝒳'.length);  // 2\n```\n\n默认情况下，正则表达式同样把一个 4 个字节的“长字符”当成一对 2 个字节长的字符。正如在字符串中遇到的情况，这将导致一些奇怪的结果。\n\n修饰符 `u` 在正则表达式中提供对 Unicode 的支持。\n\n这意味着两件事：\n\n1. 4 个字节长的字符被以正确的方式处理。\n1. Unicode 属性可以被用于查找： `\\p{…}`。\n\n有了 unicode 属性我们可以查找给定语言中的词，表情、标点符号、字母，特殊字符（引用，货币）等等。\n\n例如，使用 Unicode 属性（`\\p{L}`）能够正确匹配任何语言的字母：\n\n![image-20220907220759780](/images/regexp-learn/image-20220907220759780.png)\n\n`y` 开启粘性模式。\n\n标记 `y` 使 `regexp.exec` 正好在 `lastIndex` 位置，而不是在它之前，也不是在它之后。\n\n开启粘性模式后，正则表达式引擎只会搜索`lastIndex`位置上字符，不会往前搜索，也不会往后搜索。\n\n```javascript\n// 从其中读取变量名\nconst str = 'let varName = \"value\"';\nconst regexp = /\\w+/y;\n\nregexp.lastIndex = 3;\nconsole.log( regexp.exec(str) ); // null（位置 3 有一个空格，不是单词）\n\nregexp.lastIndex = 4;\nconsole.log( regexp.exec(str) ); // varName（在位置 4 的单词）\n```\n\n## 字符类与反向类\n\n**字符类（Character classes）** 是一个特殊的符号，匹配特定集中的任何符号。\n\n`\\d` - 匹配数字（0-9）。\n\n`\\w` - 匹配“单字”字符（拉丁字母或数字或下划线 `_`）。\n\n`\\s` - 匹配空格符号（包括空格，制表符 `\\t`，换行符 `\\n` 和其他少数稀有字符，例如 `\\v`，`\\f` 和 `\\r`）。\n\n**反向类**对应字符类，使用对应的字母，但是要大写，功能与字符类相反。\n\n`\\D` - 匹配非数字：除 `\\d` 以外的任何字符。\n\n`\\W` - 匹配非空格符号：除 `\\s` 以外的任何字符。\n\n`\\S` - 匹配非单字字符：除 `\\w` 以外的任何字符。\n\n## 集合与范围\n\n在方括号 `[…]` 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”。\n\n```javascript\nconsole.log( \"Mop top\".match(/[tm]op/gi) ); // []\"Mop\", \"top\"]\n```\n\n上面例子中的`[tm]` 被叫做 `集合` 。它只会匹配对应其中的一个。\n\n`范围`表示方括号可以包含**字符范围**。\n\n```javascript\nconsole.log( /[0-9]/g.test(\"1234\") );  // true\n```\n\n如果需要排除某个范围可以使`[^……]` 来排除范围匹配。\n\n```javascript\n// 查询除了字母，数字和空格之外的任意字符\nconsole.log( \"alice15@gmail.com\".match(/[^\\d\\sA-Z]/gi) ); // ['@','.']\n```\n\n注意，在集合内不需要进行转义。实际上如果不放心加上转义符也是可以的。\n\n## 量词\n\n最明显的量词便是一对引号间的数字：`{n}`。\n\n在一个字符（或一个字符类等等）后跟着一个量词，用来指出我们具体需要的数量。\n\n确切的范围数：\n\n`\\d{5}` 表示 5 位的数字，如同 `\\d\\d\\d\\d\\d`\n\n```javascript\nconsole.log( \"I'm 12345 years old\".match(/\\d{5}/) ); //  \"12345\"\n```\n\n某个范围数：\n\n```javascript\nconsole.log( \"I'm not 12, but 1234 years old\".match(/\\d{3,5}/) ); // \"1234\"\nconsole.log( \"I'm not 12, but 345678 years old\".match(/\\d{3,}/) ); // \"345678\"\n```\n\n常用的量词有三种缩写形式。\n\n`+` - 代表“一个或多个”，相当于 `{1,}`。\n\n`*` - 代表着“零个或多个”，相当于 `{0,}`。也就是说，这个字符可以多次出现或不出现。\n\n`?` - 代表“零个或一个”，相当于 `{0,1}`。换句话说，它使得符号变得可选。\n\n## 贪婪量词和惰性量词\n\n当我们想搜索出`\"\"` 内的内容时，会发现结果并不是我们预期的。\n\n```javascript\nlet reg = /\".+\"/g;\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nconsole.log( str.match(reg) ); // \"witch\" and her \"broom\"\n```\n\n这是因为正则表达式引擎默认是处于贪婪模式下的。\n\n**在贪婪模式下，量词都会尽可能地重复多次。**\n\n### 贪婪搜索\n\n正则表达式引擎的搜索算法：\n\n- 对于字符串中的每一个字符\n- 用这个模式来匹配这个字符\n- 若无法匹配移至下一个字符\n\n接下来，让我们详细说明一下模式 `\".+\"` 是如何进行搜索工作的。\n\n1. 该模式的第一个字符是一个引号 `\"`。\n\n    正则表达式引擎会逐个字符地检查 `a \"witch\" and her \"broom\" is one` 字符串是否符合模式的第一个字符，如果不符合就检查下一个字符，直到匹配模式的第一个字符。\n\n2. 检测到了 `\"` 后，引擎就尝试去匹配模式中的下一个字符（这里是`.`）。\n\n    ![image-20220702172516876](/images/regexp-learn/image-20220702172516876.png)\n\n3. 因为量词 `+`，模式中的点（.）将会重复地匹配所有字符，只有在移至字符串末尾时才停止匹配。\n\n    ![image-20220702172253523](/images/regexp-learn/image-20220702172253523.png)\n\n4. 由于字符串已经匹配完了，并且模式中还有结尾的一个 `\"` 没有进行匹配，所以这时正则表达式引擎会进行回溯。即 `+` 匹配次数 -1 ，当 `+` 的匹配次数正好对应字符串最后一个引号时，正则表达式引擎就结束匹配。\n\n5. 于是我们得到了 `\"witch\" and her \"broom\"` 。\n\n### 惰性模式\n\n懒惰模式中的量词与贪婪模式中的是相反的。它想要“重复最少次数”。\n\n我们能够通过在量词之后添加一个问号 `'?'` 来启用它。\n\n所以匹配模式变为 `*?` 或 `+?`，甚至将 `'?'` 变为 `??` 。\n\n```javascript\nconst reg = /\".+?\"/g;\nconst str = 'a \"witch\" and her \"broom\" is one';\n\nconsole.log( str.match(reg) ); // [witch, broom]\n```\n\n这是因为引擎在执行模式中的量词时，会判断模式中的下一个字符（这里是 `\"`），与字符串中的下一个字符是否相同，若相同就返回匹配项。\n\n### 代替方法\n\n```javascript\nconst reg = /\"[^\"]+\"/g;\nconst str = 'a \"witch\" and her \"broom\" is one';\n\nconsole.log( str.match(reg) ); // [witch, broom]\n```\n\n## 捕获组\n\n模式的一部分可以用括号括起来 `(...)`。这称为“捕获组（capturing group）”。\n\n这有两个影响：\n\n1. 它允许将匹配的一部分作为结果数组中的单独项。\n\n    ```javascript\n    const str = '<h1>Hello, world!</h1>';\n    const tag = str.match(/<(.*?)>/);\n\n    console.log(tag); // [\"<h1>\", \"h1\"] ，其中 h1 为捕获组的匹配项。\n    ```\n\n2. 如果我们将量词放在括号后，则它将括号视为一个整体。\n\n    ```javascript\n    console.log( 'Gogogo now!'.match(/(go)+/i) ); // \"Gogogo\"\n    ```\n\n当有多个捕获组时：\n\n```javascript\nconst str = '<span class=\"my\">';\nconst regexp = /<(([a-z]+)\\s*([^>]*))>/;\nconst result = str.match(regexp);\n\nconsole.log(result[0]); // <span class=\"my\">\nconsole.log(result[1]); // span class=\"my\"\nconsole.log(result[2]); // span\nconsole.log(result[3]); // class=\"my\"\n```\n\n虽然我们可以通过，像`result[1... (13351 total length)",
    "meta": {
      "title": "JavaScript 之正则表达式",
      "date": "2022-7-2",
      "tags": [
        "Regexp"
      ],
      "publish": "Regexp",
      "description": "正则表达式学习笔记"
    }
  }
]